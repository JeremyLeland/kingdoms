<title>Worker fells a tree</title>
<link rel="stylesheet" href="../style.css">

<script type="module">

import { mat4, vec3 } from '../lib/gl-matrix.js';
import { GLCanvas } from '../src/common/GLCanvas.js';
import { MatrixStack } from '../src/common/MatrixStack.js';

import { OrbitCamera, Scene } from '../src/common/Scene.js';

import * as MeshCommon from '../src/common/MeshCommon.js';
import * as ShaderCommon from '../src/common/ShaderCommon.js';
import * as Util from '../src/common/Util.js';

import * as Buildings from '../src/entities/Buildings.js';
import * as Environment from '../src/entities/Environment.js';
import * as Resources from '../src/entities/Resources.js';
import * as Worker from '../src/entities/Worker.js';
import * as Entity from '../src/Entity.js';


const canvas = new GLCanvas();
const scene = new Scene( /*canvas.gl */ );


//
// Persist camera state between sessions
// TODO: Make this part of Scene, maybe? Pass in the state key name to use
//
const TestStateKey = 'kingdoms_workerFellTestState';

const oldState = JSON.parse( localStorage.getItem( TestStateKey ) );
if ( oldState ) {
  scene.camera = new OrbitCamera( oldState );
}

window.addEventListener( 'beforeunload', ( e ) =>
  localStorage.setItem( TestStateKey, JSON.stringify( scene.camera ) )
);


const entities = [
  {
    type: 'Worker', 
    pos: [ 0, 0, 3 ],
    rot: [ 0, 0, 0 ],
    carry: [
    ],
    delay: 0,
    job: 'Harvest',
  },
  {
    type: 'Worker', 
    pos: [ 1, 0, 3 ],
    rot: [ 0, 0, 0 ],
    carry: [
    ],
    delay: 0,
    job: 'Harvest',
  },
  {
    type: 'Stockpile',
    pos: [ -3, 0, 3 ],
    pile: [],
  },
  {
    type: 'Stockpile',
    pos: [ -2, 0, 3 ],
    pile: [],
  },
  {
    type: 'Ground',
    pos: [ 0, 0, 0 ],
  },
  {
    type: 'Tree',
    health: 4,
    pos: [ 0, 0, 0 ],
  },
  {
    type: 'Tree',
    health: 4,
    pos: [ 3, 0, 0 ],
  },
  {
    type: 'Tree',
    health: 4,
    pos: [ 2, 0, 2 ],
  },
];

canvas.update = ( dt ) => {
 
  const workers = entities.filter( e => e.type == 'Worker' );

  entities.forEach( entity => {

    if ( entity.animation ) {
      entity.animation.time += dt;

      // if ( entity.animation.time < Entity.ModelInfo[ entity.type ].animations[ entity.animation.name ].duration ) {
      //   return;    // TODO: Only bail if certain animations are playing? Or should this just be part of delay?
      // }

      // TODO: Clear animation when done? stay at last frame? (Loop it if it loops)
    }

    if ( entity.delay > 0 ) {
      entity.delay -= dt;   // or max( delay - dt, zero )?
      return;
    }

    if ( entity.type == 'Worker' ) {
      updateWorker( entity, workers, dt );
    }

    if ( entity.type == 'Tree' ) {
      if ( entity.action == 'impact' ) {
        entity.health -= 1;   // eventually: entity cut damage? (so better axes cut faster)

        if ( entity.health > 0 ) {
          entity.animation = {
            name: 'impact',
            time: 0,
          };
          entity.delay = 500;
          entity.action = 'idle';
        }
        else {
          entity.animation = {
            name: 'fell',
            time: 0,
          };
          entity.delay = 2000;
          entity.action = 'sink';

          // Spawn some wood!
          const SPAWN_COUNT = 8, SPAWN_DIST = 1.5;
          for ( let i = 0; i < SPAWN_COUNT; i ++ ) {
            const angle = ( i / SPAWN_COUNT ) * Math.PI * 2;

            const dist = SPAWN_DIST;
            const offset = [ dist * Math.cos( angle ), 0, dist * Math.sin( angle ) ];

            entities.push( { 
              type: 'Wood',
              pos: vec3.add( [], entity.pos, offset ),
              rot: [ 0, -angle, 0 ],
            } );
          }
        }
      }
      else if ( entity.action == 'sink' ) {
        entity.animation = {
          name: 'sink',
          time: 0,
        };
        entity.delay = 2000;
        entity.action = 'dead';
      }
    }
  } );
}

function addItemToStockpile( target, item ) {
  const itemInfo = Entity.ModelInfo[ item.type ];

  const withinLayer = target.pile.length % 3;
  const layerIndex = Math.floor( target.pile.length / 3 );

  const horiz = ( -1 + withinLayer ) * itemInfo.bounds[ 0 ] * 3;
  const vert = layerIndex * itemInfo.bounds[ 1 ] * 2;

  if ( layerIndex % 2 == 0 ) {
    item.pos = [ horiz, vert, 0 ];
    item.rot = [ 0, 0, 0 ];
  }
  else {
    item.pos = [ 0, vert, horiz ];
    item.rot = [ 0, Math.PI / 2, 0 ];
  }

  item.rot[ 1 ] += ( -0.5 + Math.random() ) * 0.15;

  target.pile.push( item );
}

const CARRY_MAX = 3;
const CARRY_GAP = 0.05;
const STOCKPILE_MAX = 9;

const WorkerActions = {
  DropOff: {
    targetFunc: ( entity ) => {
      const stockpiles = entities.filter( e => e.type == 'Stockpile' );
      const matchingPiles = stockpiles.filter( e =>
        e.pile.length > 0 && e.pile[ 0 ].type == entity.carry[ 0 ].type &&
        e.pile.length < STOCKPILE_MAX
      );

      if ( matchingPiles.length > 0 ) {
        return closestTo( entity, matchingPiles );
      }
      else {
        const emptyPiles = stockpiles.filter( e => e.pile.length == 0 );

        return closestTo( entity, emptyPiles )
      }
    },
    actionFunc: ( entity, target ) => {
      const item = entity.carry.splice( entity.carry.length - 1, 1 )[ 0 ];

      addItemToStockpile( target, item );

      // TODO: Stockpile delay as well? (so different people can't dump a bunch of things at once)

      entity.delay += Worker.Info.UnloadDelay;
    },
  },
  PickUp: {
    targetFunc: ( entity ) => {
      const matchFunc = entity.carry.length > 0 ? e => e.type == entity.carry[ 0 ].type : e => e.type == 'Wood' || e.type == 'Stone';
      const resources = entities.filter( matchFunc );
      return closestTo( entity, resources );
    },
    actionFunc: ( entity, target ) => {
      const itemInfo = Entity.ModelInfo[ target.type ];

      target.pos = [ 0, entity.carry.length * ( itemInfo.bounds[ 1 ] * 2 + CARRY_GAP ), 0 ];
      target.rot = [ 0, 0, 0 ];

      entity.carry.push( ...entities.splice( entities.indexOf( target ), 1 ) );
      entity.delay += Worker.Info.PickupDelay;
    },
  },
  Harvest: {
    targetFunc: ( entity ) => {
      return closestTo( entity,
        entities.filter( e => e.type == 'Tree' && e.health > 0 )
      );
    },
    actionFunc: ( entity, target ) => {
      entity.animation = {
        name: 'swing',
        time: 0,
      };
      entity.delay = 1000;

      target.action = 'impact';
      target.delay = 400;

      // TODO: Should we delay here? Maybe better to cancel further updating if certain animations are in proress
    },
  }
}

// TODO: Trying to figure out how to sequence this:
//       1) Start worker swing animation
//       2) 400ms later, damage tree and start impact or fell animation
//       3) If tree dead, wait 400ms then spawn wood


function closestTo( target, entities ) {
  let closestEntity, closestDist = Infinity;
  
  entities.forEach( e => {
    if ( e != target ) {
      const dist = Math.hypot( e.pos[ 0 ] - target.pos[ 0 ], e.pos[ 2 ] - target.pos[ 2 ] );
      if ( dist < closestDist ) {
        closestEntity = e;
        closestDist = dist;
      }
    }
  } );

  return closestEntity;
}

function updateWorker( entity, others, dt ) {
  // Find avoid vectors
  const avoid = [ 0, 0, 0 ];

  others.forEach( other => {
    if ( entity != other ) {
      const cx = entity.pos[ 0 ] - other.pos[ 0 ];
      const cy = entity.pos[ 2 ] - other.pos[ 2 ];
      const dist = Math.hypot( cx, cy );
      const angle = Math.atan2( cy, cx );

      const weight = 10 * ( 1 - Math.tanh( dist ) );

      avoid[ 0 ] += weight * Math.cos( angle );
      avoid[ 2 ] += weight * Math.sin( angle );
    }
  } );

  //console.log( entity.pos + " avoid: " + avoid );

  entity.avoid = avoid;


  const woodCount = entities.filter( e => e.type == 'Wood' ).length;

  if ( woodCount == 0 ) {
    if ( entity.carry.length > 0 && entity.carry[ 0 ].type == 'Wood' ) {
      entity.job = 'DropOff';
    }
    else {
      entity.job = 'Harvest';
      entity.carry = [ { type: 'Axe' } ];
    }
  }

  if ( entity.job == 'Harvest' ) {
    if ( woodCount > 0 ) {
      entity.job = 'PickUp';
      entity.carry = [];
    }
  }

  if ( entity.job == 'PickUp' && entity.carry.length >= CARRY_MAX ) {
    entity.job = 'DropOff';
  }

  if ( entity.job == 'DropOff' && entity.carry.length == 0 ) {
    entity.job = 'PickUp';
  }

  const workerAction = WorkerActions[ entity.job ];
  //const workerAction = entity.carry.length >= CARRY_MAX ? WorkerActions.DropOff : WorkerActions.PickUp;
  const target = workerAction?.targetFunc( entity );

  // Get target vector, but also get avoid vectors, then move appropriately

  // TODO: May want to avoid even if we don't have a target (i.e. move out of way of others?)

  if ( target ) {

    const toTarget = vec3.sub( [], target.pos, entity.pos );
    const goalVec = vec3.normalize( [], toTarget );

    vec3.add( goalVec, goalVec, entity.avoid );


    const currentAngle = entity.rot[ 1 ];
    const desiredAngle = Math.atan2( -goalVec[ 2 ], goalVec[ 0 ] );   // need to flip Z here
    const angleFrom = Util.deltaAngle( currentAngle, desiredAngle )
    
    entity.rot[ 1 ] += sigma( angleFrom ) * Worker.Info.TurnSpeed * dt;
    
    const distanceFrom = vec3.len( toTarget );
    
    // TODO: Do we need to separate concept of moving toward immediate goal (which may include avoidance)
    //       and being in range of target? Otherwise, I'd be moving slowly to avoid if near target...
    //       which may be ok

    // TODO: Incorporate angleFrom into how fast we try to move. (e.g. move slower if we are turning,
    //       so we don't make such wide circles). If we are having to do a big avoid, may be better to stay
    //       in place while turning so other can more easily go around us.

    // TODO: Should we have an WorkerAction.actionDistance function? (for ranged actions like shooting?)
    //       For now, just use width (someday -- figure out proper distance for wide and narrow objects?)
    const goalDist = Entity.ModelInfo[ entity.type ].bounds[ 0 ] + Entity.ModelInfo[ target.type ].bounds[ 0 ];

    if ( distanceFrom > goalDist ) { 
      const angle = entity.rot[ 1 ]
      const moveDist = sigma( distanceFrom ) * Worker.Info.WalkSpeed * dt;
      entity.pos[ 0 ] += Math.cos( angle ) * moveDist;
      entity.pos[ 2 ] -= Math.sin( angle ) * moveDist;    // need to flip Z here
    }
    else {
      workerAction.actionFunc( entity, target );
    }
  }
}


// Play with different functions here
function sigma( x ) {
  return Math.tanh( 10 * x );
}

function bump( x ) {
  if ( x < 0 )  return 0;
  if ( x > 1 )  return 1;
  return Math.sin( x * Math.PI / 2 );
}


const modelMatrixStack = new MatrixStack( mat4.create() );

// TODO: Draw grid for ground (to help us see where things are and if they are underground)
const gridMesh = MeshCommon.Grid();
const gridModelMatrix = mat4.create();

canvas.draw = ( gl ) => {

  const fieldOfView = 45 * Math.PI / 180; // in radians
  const zNear = 0.1;
  const zFar = 100.0;
  mat4.perspective( scene.projectionMatrix, fieldOfView, canvas.canvas.width / canvas.canvas.height, zNear, zFar );

  scene.drawLines( gl, gridMesh, gridModelMatrix );

  entities.forEach( entity => {
    Entity.draw( gl, entity, scene, modelMatrixStack );
  } );
}

canvas.start();


const X_TURN_SENSITIVITY = 100;
const Y_TURN_SENSITIVITY = -100;
const X_MOVE_SENSITIVITY = -50;
const Y_MOVE_SENSITIVITY = -50;

canvas.canvas.addEventListener( 'pointermove', e => {
  // Rotate around origin with left mouse button
  if ( e.buttons == 1 ) {
    const dPhi   = e.movementX / X_TURN_SENSITIVITY;
    const dTheta = e.movementY / Y_TURN_SENSITIVITY;

    scene.camera.rotate( dPhi, dTheta );
  }

  // Pan with right mouse button
  else if ( e.buttons == 2 ) {
    const dx = e.movementX / X_MOVE_SENSITIVITY;
    const dy = e.movementY / Y_MOVE_SENSITIVITY;

    scene.camera.pan( dx, dy );
  }
} );

const ZOOM_SENSIVITY = -200;

canvas.canvas.addEventListener( 'wheel', e => {
  scene.camera.zoom( e.wheelDelta / ZOOM_SENSIVITY );
} );

</script>
