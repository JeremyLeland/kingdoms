<title>Multiple workers</title>
<link rel="stylesheet" href="../style.css">

<script type="module">

import { mat4 } from '../lib/gl-matrix.js';
import { GLCanvas } from '../src/common/GLCanvas.js';
import { MatrixStack } from '../src/common/MatrixStack.js';
import * as MeshCommon from '../src/common/MeshCommon.js';
import * as ShaderCommon from '../src/common/ShaderCommon.js';
import * as Util from '../src/common/Util.js';

import * as Buildings from '../src/entities/Buildings.js';
import * as Resources from '../src/entities/Resources.js';
import * as Worker from '../src/entities/Worker.js';


const canvas = new GLCanvas();

const camera = {
  origin: [ 0, 0, 0 ],
  distance: 10,
  phi: Math.PI / 2,
  theta: Math.PI / 4,
}

const ModelInfo = {
  'Wood': Resources.WoodModel,
  'Stone': Resources.StoneModel,
  'Stockpile': Buildings.StockpileModel,
  'Worker': Worker.Model,
};

const Meshes = new Map();

const shader = ShaderCommon.getShader( canvas.gl, ShaderCommon.BasicLighting );

// TODO: How to handle IDs? 
//   - Should we make this a map? Can't serialize/deserialize as nicely that way, though
//   - How to generate? Just keep a running index every time something is added?
//   - Maybe we don't need to do this, if we move items into "carrying", "pile", etc
const entities = [
  {
    id: 1, 
    type: 'Worker', 
    pos: [ 2, 0, 0 ],
    rot: [ 0, 0, 0 ],
    carry: [
      { type: 'Stone' },
    ],
  },
  { 
    id: 2, 
    type: 'Worker', 
    pos: [ 0, 0, 2 ], 
    rot: [ 0, -2, 0 ],
    carry: [ 
      { type: 'Wood' },
      { type: 'Wood' },
    ],
  },
  {
    type: 'Stockpile',
    pos: [ 3, 0, 3 ],
    pile: [
      { type: 'Wood' },
      { type: 'Wood' },
      { type: 'Wood' },
      { type: 'Wood' },
    ]
  }
];

// TODO: Walk to wood on ground, pick up, carry to pile, add to pile
// First step: already carrying wood, take it to pile and transfer it

let animationTime = 0;    // TODO: Per entity

canvas.update = ( dt ) => {
  // animationTime += dt;
  // animationTime = ( animationTime + dt ) % Worker.Info.WalkTime;

  // Drop off wood test
  entities.filter( e => e.type == 'Worker' ).forEach( entity => {
    // const entity = entities[ 1 ];
    const target = entities[ 2 ];

    const [ tx, ty, tz ] = target.pos;
    const [ px, py, pz ] = entity.pos;

    const currentAngle = entity.rot[ 1 ];
    const desiredAngle = Math.atan2( pz - tz, tx - px );   // need to flip Z here?
    const angleFrom = Util.deltaAngle( currentAngle, desiredAngle )
    
    entity.rot[ 1 ] += sigma( angleFrom ) * Worker.Info.TurnSpeed * dt;

    const distanceFrom = Math.hypot( tx - px, tz - pz );
    
    if ( distanceFrom > 1 ) { 
      const angle = entity.rot[ 1 ]
      const moveDist = sigma( distanceFrom ) * Worker.Info.WalkSpeed * dt;
      entity.pos[ 0 ] += Math.cos( angle ) * moveDist;
      entity.pos[ 2 ] -= Math.sin( angle ) * moveDist;    // need to flip Z here?
    }
    else {
      if ( entity.carry.length > 0 ) {
        target.pile.push( ...entity.carry.splice( 0 ) );

        // TODO: Unload one at a time with delay between
      }
    }
  } );
}

// Play with different functions here
function sigma( x ) {
  return Math.tanh( 10 * x );
}

function bump( x ) {
  if ( x < 0 )  return 0;
  if ( x > 1 )  return 1;
  return Math.sin( x * Math.PI / 2 );
}

const viewMatrix = mat4.create();

function updateViewMatrix() {
  const x = camera.distance * Math.cos( camera.phi ) * Math.sin( camera.theta );
  const y = camera.distance * Math.cos( camera.theta );
  const z = camera.distance * Math.sin( camera.phi ) * Math.sin( camera.theta );

  mat4.lookAt(
    viewMatrix,
    [ x, y, z ],
    [ 0, 0, 0 ],
    [ 0, 1, 0 ],
  );
}
updateViewMatrix();

const projectionMatrix = mat4.create();
const projViewMatrix = mat4.create();

// TODO: Draw grid for ground (to help us see where things are and if they are underground)

canvas.draw = ( gl ) => {

  const fieldOfView = 45 * Math.PI / 180; // in radians
  const zNear = 0.1;
  const zFar = 100.0;
  mat4.perspective( projectionMatrix, fieldOfView, canvas.canvas.width / canvas.canvas.height, zNear, zFar );
  mat4.multiply( projViewMatrix, projectionMatrix, viewMatrix );

  entities.forEach( entity => {
    drawEntity( gl, entity );
  } );
}

canvas.start();


function applyTransforms( matrix, transform ) {
  if ( transform.pos ) {
    mat4.translate( matrix, matrix, transform.pos );
  }

  if ( transform.rot ) {
    mat4.rotate( matrix, matrix, transform.rot[ 2 ], [ 0, 0, 1 ] );
    mat4.rotate( matrix, matrix, transform.rot[ 1 ], [ 0, 1, 0 ] );
    mat4.rotate( matrix, matrix, transform.rot[ 0 ], [ 1, 0, 0 ] );
  }

  if ( transform.scale ) {
    mat4.scale( matrix, matrix, transform.scale );
  }
}

const modelMatrix = new MatrixStack( mat4.create() );
const mvp = mat4.create();
const normalMatrix = mat4.create();

const blend = {
  pos: [ 0, 0, 0 ],
  scale: [ 1, 1, 1 ],
};

function drawEntity( gl, entity ) {

  modelMatrix.save();

  // mat4.identity( modelMatrix.current );
  applyTransforms( modelMatrix.current, entity );

  const modelInfo = ModelInfo[ entity.type ];

  for ( const part in modelInfo ) {
    const partInfo = modelInfo[ part ];

    // if ( clearModelMatrix ) {
    //   mat4.identity( modelMatrix.current );
    // }
    // 
    // applyTransforms( modelMatrix.current, entity );

    modelMatrix.save();

    // TODO: Where should animation specific transforms go? Here?
    // Using fill to avoid garbage collection
    blend.pos.fill( 0 );
    blend.scale.fill( 1 );
    
    const keyframes = partInfo.keyframes?.walk;

    if ( keyframes ) {
      const totalTime = keyframes[ keyframes.length - 1 ].time;
      const loopTime = animationTime % totalTime;
      
      let nextIndex = 0;
      for ( let i = 0; i < keyframes.length; i ++ ) {
        if ( keyframes[ i ].time > loopTime ) {
          nextIndex = i;
          break;
        }
      }

      // NOTE: This assumes a keyframe at zero. Should we create one automatically?
      const prevFrame = keyframes[ nextIndex - 1 ];
      const nextFrame = keyframes[ nextIndex ];

      const partialTime = ( animationTime - prevFrame.time ) / ( nextFrame.time - prevFrame.time );

      for ( let i = 0; i < 3; i ++ ) {
        if ( prevFrame.pos ) {
          blend.pos[ i ] = prevFrame.pos[ i ] + partialTime * ( nextFrame.pos[ i ] - prevFrame.pos[ i ] );
        }

        if ( prevFrame.scale ) {
          blend.scale[ i ] = prevFrame.scale[ i ] + partialTime * ( nextFrame.scale[ i ] - prevFrame.scale[ i ] );
        }
      }

      applyTransforms( modelMatrix.current, blend );
    }

    applyTransforms( modelMatrix.current, partInfo );

    mat4.multiply( mvp, projViewMatrix, modelMatrix.current );

    mat4.invert( normalMatrix, modelMatrix.current );
    mat4.transpose( normalMatrix, normalMatrix );


    gl.useProgram( shader.program );
    gl.uniformMatrix4fv( shader.uniformLocations.mvp, false, mvp );
    gl.uniformMatrix4fv( shader.uniformLocations.normalMatrix, false, normalMatrix );

    if ( partInfo.color ) {
      gl.uniform3fv( shader.uniformLocations.color, partInfo.color );
    }

    if ( partInfo.mesh ) {
      if ( !Meshes.has( part ) ) {
        Meshes.set( part, MeshCommon.getMesh( canvas.gl, partInfo.mesh ) );
      }
      
      const mesh = Meshes.get( part );
      
      gl.bindBuffer( gl.ARRAY_BUFFER, mesh.positionBuffer );
      gl.vertexAttribPointer( shader.attribLocations.position, 3, gl.FLOAT, false, 0, 0 );
      gl.enableVertexAttribArray( shader.attribLocations.position );
      
      gl.bindBuffer( gl.ARRAY_BUFFER, mesh.normalBuffer );
      gl.vertexAttribPointer( shader.attribLocations.normal, 3, gl.FLOAT, false, 0, 0 );
      gl.enableVertexAttribArray( shader.attribLocations.normal );
      
      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer );
      gl.drawElements( gl.TRIANGLES, mesh.length, gl.UNSIGNED_SHORT, 0 );
    }

    if ( partInfo.attach ) {
      const attachList = entity[ partInfo.attach ];

      // TODO: attachFunc to iterate through list and draw? (so carry stack is done differently than pile stack, e.g.)
      attachList.forEach( attached => {
        drawEntity( gl, attached );

        // TODO: Get size from ModelInfo? Make it top level somehow? (may need an overall bounding box for selection anyway)
        mat4.translate( modelMatrix.current, modelMatrix.current, [ 0, 0.15, 0 ] );

        // How to make wood lay flat on top of ground (and not partway in it )?
        // Should all wood be offset by half its height so that 0 is the bottom instead of center?

      } );
    }

    modelMatrix.restore();
  }

  modelMatrix.restore();
}

const X_SENSITIVITY = 100;
const Y_SENSTIVITY = -100;

canvas.canvas.addEventListener( 'pointermove', e => {
  if ( e.buttons == 1 ) {
    camera.phi += e.movementX / X_SENSITIVITY;
    camera.theta = Math.max( 1e-6, Math.min( Math.PI, camera.theta + e.movementY / Y_SENSTIVITY ) );

    updateViewMatrix();
  }
} );

const MIN_DIST = 1;
const MAX_DIST = 100;
const ZOOM_SENSIVITY = -200;
canvas.canvas.addEventListener( 'wheel', e => {
  camera.distance = Math.max( MIN_DIST, Math.min( MAX_DIST, camera.distance + e.wheelDelta / ZOOM_SENSIVITY ) );

  updateViewMatrix();
} );

</script>