<title>Multiple workers</title>
<link rel="stylesheet" href="../style.css">

<script type="module">

import { mat4 } from '../lib/gl-matrix.js';
import { GLCanvas } from '../src/common/GLCanvas.js';
import { MatrixStack } from '../src/common/MatrixStack.js';
import * as MeshCommon from '../src/common/MeshCommon.js';
import * as ShaderCommon from '../src/common/ShaderCommon.js';
import * as Util from '../src/common/Util.js';

import * as Buildings from '../src/entities/Buildings.js';
import * as Resources from '../src/entities/Resources.js';
import * as Worker from '../src/entities/Worker.js';
import * as Entity from '../src/Entity.js';


const canvas = new GLCanvas();

const camera = {
  origin: [ 0, 0, 0 ],
  distance: 10,
  phi: Math.PI / 2,
  theta: Math.PI / 4,
};


const entities = [
  {
    type: 'Worker', 
    pos: [ 2, 0, 0 ],
    rot: [ 0, 0, 0 ],
    carry: [
      // { type: 'Stone' },
    ],
    animation: {
      name: 'walk',
      time: 0,
    },
    delay: 0,
  },
  {
    type: 'Worker', 
    pos: [ 0, 0, 2 ], 
    rot: [ 0, -2, 0 ],
    carry: [ 
      // { type: 'Wood', pos: [ 0, 0, 0 ] },
      // { type: 'Wood', pos: [ 0, 0.15, 0 ] },
      // { type: 'Wood', pos: [ 0, 0.3, 0 ] },
    ],
    animation: {
      name: 'walk',
      time: 0,
    },
    delay: 0,
  },
  {
    type: 'Worker', 
    pos: [ 0, 0, 0 ], 
    rot: [ 0, 0, 0 ],
    carry: [],
    animation: {
      name: 'walk',
      time: 0,
    },
    delay: 0,
  },
  {
    type: 'Stockpile',
    pos: [ 3, 0, 3 ],
    pile: [],
  },
  {
    type: 'Stockpile',
    pos: [ 4, 0, 3 ],
    pile: [],
  },
  {
    type: 'Ground',
    pos: [ 0, 0, 0 ],
    scale: [ 5, 1, 5 ],
  },
  {
    type: 'Tree',
    pos: [ 4, 0, -4 ],
  },
  {
    type: 'Tree',
    pos: [ -4, 0, -4 ],
  },
];

const stockpiles = entities.filter( e => e.type == 'Stockpile' );

for ( let i = 0; i < 10; i ++ ) {
  addItemToStockpile( stockpiles[ 0 ], { type: 'Wood' } );
}

for ( let i = 0; i < 10; i ++ ) {
  addItemToStockpile( stockpiles[ 1 ], { type: 'Stone' } );
}

for ( let row = -3; row < 3; row ++ ) {
  for ( let col = -3; col < 3; col ++ ) {
    entities.push( 
      { 
        type: 'Wood',
        pos: [ col, 0, row ],
        rot: [ 0, Math.random() * Math.PI * 2, 0 ],
      }
    );
  }
}


// TODO: Have separate function to add items to stockpile, so we can more easily test placement (and pre-position items)

canvas.update = ( dt ) => {
  // animationTime += dt;
  // animationTime = ( animationTime + dt ) % Worker.Info.WalkTime;

  // Drop off wood test
  entities.filter( e => e.type == 'Worker' ).forEach( entity => updateWorker( entity, dt ) );
}

function addItemToStockpile( target, item ) {
  const itemInfo = Entity.ModelInfo[ item.type ];

  const withinLayer = target.pile.length % 3;
  const layerIndex = Math.floor( target.pile.length / 3 );

  const horiz = ( -1 + withinLayer ) * itemInfo.bounds[ 0 ] * 3;
  const vert = layerIndex * itemInfo.bounds[ 1 ] * 2;

  if ( layerIndex % 2 == 0 ) {
    item.pos = [ horiz, vert, 0 ];
    item.rot = [ 0, 0, 0 ];
  }
  else {
    item.pos = [ 0, vert, horiz ];
    item.rot = [ 0, Math.PI / 2, 0 ];
  }

  item.rot[ 1 ] += ( -0.5 + Math.random() ) * 0.15;

  target.pile.push( item );
}

const WorkerActions = {
  DropOff: {
    targetFunc: ( entity ) => entities.find( e => e.type == 'Stockpile' && e.pile.find( p => p.type == entity.carry[ 0 ].type ) ),
    actionFunc: ( entity, target ) => {
      const item = entity.carry.splice( 0, 1 )[ 0 ];

      addItemToStockpile( target, item );

      // TODO: Stockpile delay as well? (so different people can't dump a bunch of things at once)

      entity.delay += Worker.Info.UnloadDelay;
    },
  },
  PickUp: {
    // TODO: Find closest, not just first
    targetFunc: ( entity ) => {
      const resources = entities.filter( e => e.type == 'Wood' || e.type == 'Stone' );
      return closestTo( entity, resources );
    },
    actionFunc: ( entity, target ) => {
      
      // TODO: call a target.type-specific function to get this based on index
      target.pos = [ 0, entity.carry.length * 0.15, 0 ];
      target.rot = [ 0, 0, 0 ];

      entity.carry.push( ...entities.splice( entities.indexOf( target ), 1 ) );
      entity.delay += Worker.Info.PickupDelay;
    },
  },
}

function closestTo( target, entities ) {
  let closestEntity, closestDist = Infinity;
  
  entities.forEach( e => {
    if ( e != target ) {
      const dist = Math.hypot( e.pos[ 0 ] - target.pos[ 0 ], e.pos[ 2 ] - target.pos[ 2 ] );
      if ( dist < closestDist ) {
        closestEntity = e;
        closestDist = dist;
      }
    }
  } );

  return closestEntity;
}

function updateWorker( entity, dt ) {
  // const entity = entities[ 1 ];
  // const target = entities[ 2 ];

  if ( entity.delay > 0 ) {
    entity.delay -= dt;   // or max( delay - dt, zero )?
    return;
  }

  const workerAction = entity.carry.length > 0 ? WorkerActions.DropOff : WorkerActions.PickUp;

  const target = workerAction.targetFunc( entity );

  // Get target vector, but also get avoid vectors, then move appropriately

  if ( target ) {
    const [ tx, ty, tz ] = target.pos;
    const [ px, py, pz ] = entity.pos;
    
    const currentAngle = entity.rot[ 1 ];
    const desiredAngle = Math.atan2( pz - tz, tx - px );   // need to flip Z here?
    const angleFrom = Util.deltaAngle( currentAngle, desiredAngle )
    
    entity.rot[ 1 ] += sigma( angleFrom ) * Worker.Info.TurnSpeed * dt;
    
    const distanceFrom = Math.hypot( tx - px, tz - pz );
    
    if ( distanceFrom > 1 ) { 
      const angle = entity.rot[ 1 ]
      const moveDist = sigma( distanceFrom ) * Worker.Info.WalkSpeed * dt;
      entity.pos[ 0 ] += Math.cos( angle ) * moveDist;
      entity.pos[ 2 ] -= Math.sin( angle ) * moveDist;    // need to flip Z here?
    }
    else {
      workerAction.actionFunc( entity, target );
    }
  }
}


// Play with different functions here
function sigma( x ) {
  return Math.tanh( 10 * x );
}

function bump( x ) {
  if ( x < 0 )  return 0;
  if ( x > 1 )  return 1;
  return Math.sin( x * Math.PI / 2 );
}

const viewMatrix = mat4.create();

function updateViewMatrix() {
  const x = camera.origin[ 0 ] + camera.distance * Math.cos( camera.phi ) * Math.sin( camera.theta );
  const y = camera.origin[ 1 ] + camera.distance * Math.cos( camera.theta );
  const z = camera.origin[ 2 ] + camera.distance * Math.sin( camera.phi ) * Math.sin( camera.theta );

  mat4.lookAt(
    viewMatrix,
    [ x, y, z ],
    camera.origin,
    [ 0, 1, 0 ],
  );
}
updateViewMatrix();

const projectionMatrix = mat4.create();

const modelMatrixStack = new MatrixStack( mat4.create() );

// TODO: Draw grid for ground (to help us see where things are and if they are underground)

canvas.draw = ( gl ) => {

  const fieldOfView = 45 * Math.PI / 180; // in radians
  const zNear = 0.1;
  const zFar = 100.0;
  mat4.perspective( projectionMatrix, fieldOfView, canvas.canvas.width / canvas.canvas.height, zNear, zFar );

  // TODO: Do this in shader instead
  const eyePos = [ viewMatrix[ 12 ], viewMatrix[ 13 ], viewMatrix[ 14 ], 1 ];

  entities.forEach( entity => {
    Entity.draw( entity, gl, modelMatrixStack, viewMatrix, projectionMatrix, eyePos );
  } );
}

canvas.start();


const X_TURN_SENSITIVITY = 100;
const Y_TURN_SENSITIVITY = -100;
const X_MOVE_SENSITIVITY = -50;
const Y_MOVE_SENSITIVITY = -50;

canvas.canvas.addEventListener( 'pointermove', e => {
  // Rotate around origin with left mouse button
  if ( e.buttons == 1 ) {
    camera.phi += e.movementX / X_TURN_SENSITIVITY;
    camera.theta = Math.max( 1e-6, Math.min( Math.PI, camera.theta + e.movementY / Y_TURN_SENSITIVITY ) );

    updateViewMatrix();
  }

  // Pan with right mouse button
  else if ( e.buttons == 2 ) {
    const cos = Math.cos( camera.phi );
    const sin = Math.sin( camera.phi );

    const dx = e.movementX / X_MOVE_SENSITIVITY;
    const dy = e.movementY / Y_MOVE_SENSITIVITY;

    camera.origin[ 0 ] +=  sin * dx + cos * dy;
    camera.origin[ 2 ] += -cos * dx + sin * dy;

    updateViewMatrix();
  }
} );

const MIN_DIST = 1;
const MAX_DIST = 100;
const ZOOM_SENSIVITY = -200;
canvas.canvas.addEventListener( 'wheel', e => {
  camera.distance = Math.max( MIN_DIST, Math.min( MAX_DIST, camera.distance + e.wheelDelta / ZOOM_SENSIVITY ) );

  updateViewMatrix();
} );

</script>
