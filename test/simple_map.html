<title>Simple map to play around with</title>
<link rel="stylesheet" href="../style.css">

<script type="module">
  
  import { Canvas } from '../src/common/Canvas.js';
  import { Grid } from '../src/common/Grid.js';
  import * as Entities from '../src/Entities.js';
  
  
  const entities = [
    { type: 'Tree', x: 1, y: -3 },
    { type: 'Tree', x: -1, y: -1 },
    { type: 'Tree', x: -2, y: 2 },
    { type: 'Tree', x: 0, y: 1 },
    { type: 'Farm', x: 3, y: 3 },
  ];

  let pendingEntity = {
    type: 'Farm',
    x: 0,
    y: 0,
  };

  //
  // Canvas
  //

  const canvas = new Canvas();
  canvas.backgroundColor = '#222';
  canvas.lineWidth = 0.02;
  canvas.zoom = 1 / 16;
  canvas.scrollX = -8;
  canvas.scrollY = -8;

  canvas.update = ( dt ) => {

  }

  let mouseX = 0, mouseY = 0;

  const grid = new Grid( -10, -10, 10, 10 );

  function getBlocking( entity ) {
    const info = Entities.Info[ entity.type ];
    
    return entities.filter( other => {
      const otherInfo = Entities.Info[ other.type ];
      
      return Math.abs( entity.x - other.x ) < ( info.width  + otherInfo.width  ) / 2 && 
             Math.abs( entity.y - other.y ) < ( info.height + otherInfo.height ) / 2
      }
    );
  }

  canvas.draw = ( ctx ) => {

    entities.forEach( entity => Entities.draw( ctx, entity ) );

    const blocking = getBlocking( pendingEntity );

    blocking.forEach( e => {
      const info = Entities.Info[ e.type ];

      ctx.fillStyle = '#f008';
      ctx.fillRect( e.x - info.width / 2, e.y - info.height / 2, info.width, info.height );
    } );

   
    ctx.fillStyle = '#ccc8';

    const pendingInfo = Entities.Info[ pendingEntity.type ];
    ctx.fillRect( 
      pendingEntity.x - pendingInfo.width / 2, 
      pendingEntity.y - pendingInfo.height / 2, 
      pendingInfo.width, 
      pendingInfo.height 
    );

    grid.draw( ctx );
  }

  canvas.pointerMove = p => {
    mouseX = p.x;
    mouseY = p.y;

    const info = Entities.Info[ pendingEntity.type ];

    const xOffset = info.width  / 2 - 0.5;
    const yOffset = info.height / 2 - 0.5;

    pendingEntity.x = Math.round( mouseX - xOffset ) + xOffset;
    pendingEntity.y = Math.round( mouseY - yOffset ) + yOffset;

    canvas.redraw();
  }

  canvas.pointerDown = p => {
    mouseX = p.x;
    mouseY = p.y;

    if ( getBlocking( pendingEntity ).length == 0 ) {
      const newEntity = Object.assign( {}, pendingEntity );
      entities.push( newEntity );
    }
  }

  // canvas.start();
  
</script>