<title>Scene class test</title>
<link rel="stylesheet" href="../style.css">

<script type="module">

import { mat4, vec3 } from '../lib/gl-matrix.js';
import { GLCanvas } from '../src/common/GLCanvas.js';
import { MatrixStack } from '../src/common/MatrixStack.js';

import { Scene } from '../src/common/Scene.js';

import * as MeshCommon from '../src/common/MeshCommon.js';
import * as ShaderCommon from '../src/common/ShaderCommon.js';
import * as Util from '../src/common/Util.js';

import * as Buildings from '../src/entities/Buildings.js';
import * as Resources from '../src/entities/Resources.js';
import * as Worker from '../src/entities/Worker.js';
import * as Entity from '../src/Entity.js';


const canvas = new GLCanvas();
const scene = new Scene( /*canvas.gl */ );

const camera = {
  origin: [ 0, 0, 0 ],
  distance: 10,
  phi: Math.PI / 2,
  theta: Math.PI / 4,
};


const entities = [
  {
    type: 'Tree',
    pos: [ 4, 0, -4 ],
    animation: {
      name: 'idle',
      time: 0,
    },
    delay: 0,
  },
];

const mesh = MeshCommon.Sphere();

canvas.update = ( dt ) => {
  entities.forEach( entity => entity.animation.time += dt );
}


function updateViewMatrix() {
  const x = camera.origin[ 0 ] + camera.distance * Math.cos( camera.phi ) * Math.sin( camera.theta );
  const y = camera.origin[ 1 ] + camera.distance * Math.cos( camera.theta );
  const z = camera.origin[ 2 ] + camera.distance * Math.sin( camera.phi ) * Math.sin( camera.theta );

  mat4.lookAt(
    scene.viewMatrix,
    [ x, y, z ],
    camera.origin,
    [ 0, 1, 0 ],
  );
}
updateViewMatrix();


const modelMatrixStack = new MatrixStack( mat4.create() );

// TODO: Draw grid for ground (to help us see where things are and if they are underground)

canvas.draw = ( gl ) => {

  const fieldOfView = 45 * Math.PI / 180; // in radians
  const zNear = 0.1;
  const zFar = 100.0;
  mat4.perspective( scene.projectionMatrix, fieldOfView, canvas.canvas.width / canvas.canvas.height, zNear, zFar );

  entities.forEach( entity => {
    // scene.draw( gl, Entity.ModelInfo[ entity.type ], ShaderCommon.Lighting, modelMatrixStack.current );
    scene.draw( gl, mesh, ShaderCommon.Lighting, modelMatrixStack.current );
  } );
}

canvas.start();


const X_TURN_SENSITIVITY = 100;
const Y_TURN_SENSITIVITY = -100;
const X_MOVE_SENSITIVITY = -50;
const Y_MOVE_SENSITIVITY = -50;

canvas.canvas.addEventListener( 'pointermove', e => {
  // Rotate around origin with left mouse button
  if ( e.buttons == 1 ) {
    camera.phi += e.movementX / X_TURN_SENSITIVITY;
    camera.theta = Math.max( 1e-6, Math.min( Math.PI, camera.theta + e.movementY / Y_TURN_SENSITIVITY ) );

    updateViewMatrix();
  }

  // Pan with right mouse button
  else if ( e.buttons == 2 ) {
    const cos = Math.cos( camera.phi );
    const sin = Math.sin( camera.phi );

    const dx = e.movementX / X_MOVE_SENSITIVITY;
    const dy = e.movementY / Y_MOVE_SENSITIVITY;

    camera.origin[ 0 ] +=  sin * dx + cos * dy;
    camera.origin[ 2 ] += -cos * dx + sin * dy;

    updateViewMatrix();
  }
} );

const MIN_DIST = 1;
const MAX_DIST = 100;
const ZOOM_SENSIVITY = -200;
canvas.canvas.addEventListener( 'wheel', e => {
  camera.distance = Math.max( MIN_DIST, Math.min( MAX_DIST, camera.distance + e.wheelDelta / ZOOM_SENSIVITY ) );

  updateViewMatrix();
} );

</script>
