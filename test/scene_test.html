<title>Scene class test</title>
<link rel="stylesheet" href="../style.css">

<div id="ui" style="position: absolute"></div>

<script type="module">

import { mat4, vec3 } from '../lib/gl-matrix.js';
import { GLCanvas } from '../src/common/GLCanvas.js';
import { MatrixStack } from '../src/common/MatrixStack.js';

import { Scene } from '../src/common/Scene.js';

import * as MeshCommon from '../src/common/MeshCommon.js';
import * as ShaderCommon from '../src/common/ShaderCommon.js';
import * as Util from '../src/common/Util.js';

import * as Buildings from '../src/entities/Buildings.js';
import * as Environment from '../src/entities/Environment.js';
import * as Resources from '../src/entities/Resources.js';
import * as Worker from '../src/entities/Worker.js';
import * as Entity from '../src/Entity.js';


const canvas = new GLCanvas();
const scene = new Scene( /*canvas.gl */ );

const entities = [
  {
    type: 'Worker',
    pos: [ 0, 0, 0 ],
    animation: {
      name: 'idle',
      time: 0,
    },
    delay: 0,
  },
];

const mesh = MeshCommon.Sphere();

canvas.update = ( dt ) => {
  entities.forEach( entity => entity.animation.time += dt );
}

function startAnimation( entity, name ) {
  entity.animation.name = name;
  entity.animation.time = 0;
}


const modelMatrixStack = new MatrixStack( mat4.create() );

// TODO: Draw grid for ground (to help us see where things are and if they are underground)



function linearBlend( a, b, perc ) {
  return a + perc * ( b - a );
}

function squareBlend( a, b, perc ) {
  return a + Math.pow( perc, 3 ) * ( b - a );
}

// TODO: What are some useful blends? Square, maybe? Sine isn't quite doing what I envisioned

function sineBlend( a, b, perc ) {
  return a + Math.sin( perc * Math.PI / 2 ) * ( b - a );
}

function doBlend( out, a, b, perc, func ) {
  for ( const prop in a ) {
    if ( prop != 'time' ) {
      for ( let i = 0; i < 3; i ++ ) {
        out[ prop ][ i ] = func( a[ prop ][ i ], b[ prop ][ i ], perc );
      }
    }
  }
}

const blendInfo = {
  pos: [ 0, 0, 0 ],
  rot: [ 0, 0, 0 ],
  scale: [ 1, 1, 1 ],
};

function applyAnimationTransform( modelMatrix, entity, info ) {

  // Start with info transforms if they exist, but will replace with any keyframe transforms below
  //blendInfo.pos = info.pos ?? [ 0, 0, 0 ];
  //blendInfo.rot = info.rot ?? [ 0, 0, 0 ];
  //blendInfo.scale = info.scale ?? [ 1, 1, 1 ];

  if ( entity.animation ) {
    // Using fill to avoid garbage collection
    blendInfo.pos.fill( 0 );
    blendInfo.rot.fill( 0 );
    blendInfo.scale.fill( 1 );

    const keyframes = info.keyframes?.[ entity.animation.name ];

    if ( keyframes ) {
      const percentTime = entity.animation.time / Entity.ModelInfo[ entity.type ].animations[ entity.animation.name ].duration;

      const nextIndex = keyframes.findIndex( e => e.time > percentTime );

      if ( nextIndex >= 0 ) {
        const prevFrame = keyframes[ nextIndex - 1 ];
        const nextFrame = keyframes[ nextIndex ];

        const partialTime = ( percentTime - prevFrame.time ) / ( nextFrame.time - prevFrame.time );

        doBlend( blendInfo, prevFrame, nextFrame, partialTime, linearBlend );

        Entity.applyTransforms( modelMatrix, blendInfo );
      }
      else {
        Entity.applyTransforms( modelMatrix, keyframes.at( -1 ) );
      }
    }
  }
  
  Entity.applyTransforms( modelMatrix, info );

}

canvas.draw = ( gl ) => {

  const fieldOfView = 45 * Math.PI / 180; // in radians
  const zNear = 0.1;
  const zFar = 100.0;
  mat4.perspective( scene.projectionMatrix, fieldOfView, canvas.canvas.width / canvas.canvas.height, zNear, zFar );

  entities.forEach( entity => {

    modelMatrixStack.save(); {

      Entity.applyTransforms( modelMatrixStack.current, entity );

      const modelInfo = Entity.ModelInfo[ entity.type ];

      applyAnimationTransform( modelMatrixStack.current, entity, modelInfo );

      for ( const partName in modelInfo.parts ) {
        modelMatrixStack.save(); {

          const partInfo = modelInfo.parts[ partName ];

          // TODO: Can't combine main and animated, need to do one or other
          //Entity.applyTransforms( modelMatrixStack.current, partInfo );
          applyAnimationTransform( modelMatrixStack.current, entity, partInfo );

          scene.drawMesh( gl, partInfo.mesh, partInfo.material, modelMatrixStack.current );
        }

        modelMatrixStack.restore();
      }
    }

    modelMatrixStack.restore();

    // scene.drawMesh( gl, mesh, ShaderCommon.Lighting, modelMatrixStack.current );
  } );
}

canvas.start();


const X_TURN_SENSITIVITY = 100;
const Y_TURN_SENSITIVITY = -100;
const X_MOVE_SENSITIVITY = -50;
const Y_MOVE_SENSITIVITY = -50;

canvas.canvas.addEventListener( 'pointermove', e => {
  // Rotate around origin with left mouse button
  if ( e.buttons == 1 ) {
    const dPhi   = e.movementX / X_TURN_SENSITIVITY;
    const dTheta = e.movementY / Y_TURN_SENSITIVITY;

    scene.camera.rotate( dPhi, dTheta );
  }

  // Pan with right mouse button
  else if ( e.buttons == 2 ) {
    const dx = e.movementX / X_MOVE_SENSITIVITY;
    const dy = e.movementY / Y_MOVE_SENSITIVITY;

    scene.camera.pan( dx, dy );
  }
} );

const ZOOM_SENSIVITY = -200;

canvas.canvas.addEventListener( 'wheel', e => {
  scene.camera.zoom( e.wheelDelta / ZOOM_SENSIVITY );
} );


//
// UI
//
const divUI = document.getElementById( 'ui' );

for ( const name in Worker.Model.animations ) {
  const button = document.createElement( 'button' );
  button.innerText = name;
  button.addEventListener( 'click', e => {
    startAnimation( entities[ 0 ], name );
  } );

  divUI.appendChild( button );
}

</script>
