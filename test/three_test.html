<title>ThreeJS test</title>
<link rel="stylesheet" href="../style.css">

<script type="module">
  import * as THREE from '../lib/threejs/three.module.js';
  import { ThreeGame } from '../src/common/ThreeGame.js';
  import { OrbitControls } from '../lib/threejs/OrbitControls.js';
  import { ValuesPanel } from '../src/common/ValuesPanel.js';

  const Info = {
    Person: {
      HeadSize: 0.4,
      Neck: 0.2,
      BodyWidth: 0.5,
      BodyHeight: 1.5,
      HandSize: 0.1,
      CarryDown: 0.5,
      CarryAway: 0.1,
    },
    Tree: {
      TrunkWidth: 0.3,
      TrunkHeight: 0.5,
      TopWidth: 1,
      TopHeight: 1.5,
    },
  }

  // new ValuesPanel( Info );

  const game = new ThreeGame();
  game.scene.background = new THREE.Color( 0x000022 );
  game.camera.position.set( 5, 5, 5 );
  game.camera.lookAt( 0, 0, 0 );

  const controls = new OrbitControls( game.camera, game.renderer.domElement );
  controls.target.set( 0, 0, 0 );
  // controls.minDistance = 1;
  // controls.maxDistance = 10;
  controls.update();


  game.scene.add( new THREE.AxesHelper( 5 ) );

  const grid = new THREE.GridHelper( 10, 10 );
  grid.material.opacity = 0.2;
  grid.material.transparent = true;
  game.scene.add( grid );

  game.scene.add( new THREE.AmbientLight( 0xffffff, 0.4 ) );

  const light = new THREE.DirectionalLight( 0xffffff, 0.8 );
  light.position.set( 0, 1, 2 );
  light.target.position.set( 0, 0, 0 );
  game.scene.add( light );

  //
  // Ground
  //
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry( 10, 10 ),
    new THREE.MeshPhongMaterial( { color: 0x442200 } ),
  );

  ground.rotation.set( -Math.PI / 2, 0, 0 );

  game.scene.add( ground );

  //
  // Worker
  //
  const body = new THREE.Mesh( 
    new THREE.SphereGeometry( 1, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2 ), 
    new THREE.MeshPhongMaterial( { color: 'blue' } ),
  );
  
  const head = new THREE.Mesh( 
    new THREE.SphereGeometry( 1, 32, 32 ), 
    new THREE.MeshPhongMaterial( { color: 'tan' } ),
  );

  const hands = Array.from( Array( 2 ), _ => 
    new THREE.Mesh(
      new THREE.SphereGeometry( Info.Person.HandSize, 32, 32 ),
      new THREE.MeshPhongMaterial( { color: 'tan' } ),
    )
  );

  const wood = Array.from( Array( 7 ), _ => { 

    const col = 0.5 * Math.random() + 0.25;

    return new THREE.Mesh(
      new THREE.BoxGeometry( 1, 0.1, 0.2 ),
      // new THREE.MeshPhongMaterial( { color: new THREE.Color( col, col / 2, 0 ) } ),
      new THREE.MeshPhongMaterial( { color: 'brown' } ),
    ); 
  } );
  
  const worker = new THREE.Group();
  worker.add( body );
  worker.add( head );
  // worker.add( wood[ 0 ] );
  worker.add( hands[ 0 ] );
  worker.add( hands[ 1 ] );
  

  game.scene.add( worker );

  //
  // Tree
  //
  const trunk = new THREE.Mesh(
    new THREE.CylinderGeometry( Info.Tree.TrunkWidth, Info.Tree.TrunkWidth, Info.Tree.TrunkHeight, 32 ),
    new THREE.MeshPhongMaterial( { color: 'brown' } ),
  );

  trunk.position.set( 0, Info.Tree.TrunkHeight / 2, 0 );

  const treeTopMaterial = new THREE.MeshPhongMaterial( { color: 'green' } );

  const top = new THREE.Group();
  
  for ( let i = 0; i < 3; i ++ ) {
    const mesh = new THREE.Mesh(
      new THREE.ConeGeometry( Info.Tree.TopWidth, Info.Tree.TopHeight, 32 ),
      treeTopMaterial,
    );

    mesh.position.set( 0, Info.Tree.TrunkHeight + Info.Tree.TopHeight / 2 + i / 2, 0 );

    const size = 1 - 0.2 * i;
    mesh.scale.set( size, size, size );

    top.add( mesh );
  }

  const tree = new THREE.Group();
  tree.add( trunk );
  tree.add( top );

  game.scene.add( tree );

  const stockpile = new THREE.Mesh(
    new THREE.BoxGeometry( 1, 0.1, 1 ),
    new THREE.MeshPhongMaterial( { color: 'gray' } ),
  );

  stockpile.position.set( 3, 0.1 / 2, 3 );

  let index = 1, level = 1;

  wood.forEach( ( plank, index ) => {
    const col = index % 3;
    const level = Math.floor( index / 3 ) + 1;

    const offset = 1/3 * ( col - 1 );

    plank.position.x = 3 + ( level % 2  ? offset : 0 );
    plank.position.y = 0.1 / 2 + 0.1 * level;
    plank.position.z = 3 + ( level % 2  ? 0 : offset );

    if ( level % 2 ) {
      plank.rotation.y = Math.PI / 2;
    }

    game.scene.add( plank );
  } );

  game.scene.add( stockpile );

  const DURATION = 1000;

  const FELL_DURATION = 1500;

  let animationTime = 0;

  game.start( ( dt ) => {
    animationTime += dt;

    //
    // Person
    //
    const bodyHeight = Info.Person.BodyHeight - 0.25 * Math.sin( Math.PI * 2 * ( animationTime % DURATION ) / DURATION );

    body.scale.set( Info.Person.BodyWidth, bodyHeight, Info.Person.BodyWidth );

    head.scale.set( Info.Person.HeadSize, Info.Person.HeadSize, Info.Person.HeadSize ); 
    head.position.set( 0, bodyHeight + Info.Person.HeadSize - Info.Person.Neck, 0 );


    hands[ 0 ].position.set( -0.5, bodyHeight - Info.Person.CarryDown, Info.Person.BodyWidth + Info.Person.CarryAway );
    hands[ 1 ].position.set(  0.5, bodyHeight - Info.Person.CarryDown, Info.Person.BodyWidth + Info.Person.CarryAway );

    // wood[ 0 ].position.set( 0, bodyHeight - Info.Person.CarryDown, Info.Person.BodyWidth + Info.Person.CarryAway );

    const WALK_RADIUS = 3, WALK_TIME = 12000;
    const theta = Math.PI * 2 * ( animationTime % WALK_TIME ) / WALK_TIME;

    worker.position.set( WALK_RADIUS * Math.cos( theta ), 0, WALK_RADIUS * Math.sin( theta ) );
    worker.rotation.set( 0, -theta, 0 );

    //
    // Tree
    //

    if ( animationTime < FELL_DURATION ) {
      top.rotation.z = Math.PI / 2 * ( 1 - Math.cos( Math.PI / 2 * animationTime / FELL_DURATION ) );
    }

  } );

</script>
